(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{78:function(e,n,t){"use strict";t.r(n),t.d(n,"frontMatter",(function(){return r})),t.d(n,"metadata",(function(){return i})),t.d(n,"rightToc",(function(){return l})),t.d(n,"default",(function(){return u}));var o=t(2),c=t(6),a=(t(0),t(99)),r={id:"batched",title:"batched",sidebar_label:"batched"},i={unversionedId:"guides/batched",id:"guides/batched",isDocsHomePage:!1,title:"batched",description:"Batched functions enable you to make multiple state changes without triggering observer effects too frequently. batched takes in a function and returns a function with an identical signature to the passed function. Under the hood a batched function will create a new transaction that will be commited at the end of the functions execution and will be rolled back if the passed function throws an error.",source:"@site/docs/guides/batched.md",slug:"/guides/batched",permalink:"/elementos-docs/docs/guides/batched",editUrl:"https://github.com/facebook/docusaurus/edit/master/website/docs/guides/batched.md",version:"current",sidebar_label:"batched",sidebar:"main",previous:{title:"observe",permalink:"/elementos-docs/docs/guides/observe"},next:{title:"Overview",permalink:"/elementos-docs/docs/react/overview"}},l=[{value:"Basic",id:"basic",children:[]},{value:"Rollbacks",id:"rollbacks",children:[]},{value:"Gets and Sets",id:"gets-and-sets",children:[]}],s={rightToc:l};function u(e){var n=e.components,t=Object(c.a)(e,["components"]);return Object(a.b)("wrapper",Object(o.a)({},s,t,{components:n,mdxType:"MDXLayout"}),Object(a.b)("p",null,"Batched functions enable you to make multiple state changes without triggering observer effects too frequently. ",Object(a.b)("inlineCode",{parentName:"p"},"batched")," takes in a function and returns a function with an identical signature to the passed function. Under the hood a batched function will create a new transaction that will be commited at the end of the functions execution and will be rolled back if the passed function throws an error."),Object(a.b)("h3",{id:"basic"},"Basic"),Object(a.b)("p",null,"Before we use batched, let's look at an example that doesn't use batched udpates. Notice how the observer effect runs twice when we call ",Object(a.b)("inlineCode",{parentName:"p"},"incrementAll"),"."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { atom, molecule, observe, batched  } from 'elementos'\n\nconst counts$ = molecule({\n  count1: atom(10),\n  count2: atom(10)\n}, {\n  actions: ({ count1, count2 }) => ({\n    incrementAll: () => {\n      count1.actions.increment()\n      count2.actions.increment()\n    }\n  })\n})\n\nobserve(counts$, (counts) => {\n  console.log(counts)\n})\n\ncounts$.actions.incrementAll()\n\n// Output:\n// { count1: 10, count2: 10 }\n// { count1: 11, count2: 10 }\n// { count1: 11, count2: 11 }\n")),Object(a.b)("p",null,"This is likely not the behavior we intend, but by batching ",Object(a.b)("inlineCode",{parentName:"p"},"incrementAll")," we can ensure that observer effect will run only once at the end of the batched function's execution."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { atom, molecule, observe, batched  } from 'elementos'\n\nconst counts$ = molecule({\n  count1: atom(10),\n  count2: atom(10)\n}, {\n  actions: ({ count1, count2 }) => ({\n    incrementAll: batched(() => {\n      count1.actions.increment()\n      count2.actions.increment()\n    })\n  })\n})\n\nobserve(counts$, (counts) => {\n  console.log(counts)\n})\n\ncounts$.actions.incrementAll()\n\n// Output:\n// { count1: 10, count2: 10 }\n// { count1: 11, count2: 11 }\n")),Object(a.b)("h3",{id:"rollbacks"},"Rollbacks"),Object(a.b)("p",null,"If the batched function throws an error, the state changes will not be committed, and the observer effect will not run."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { atom, molecule, observe, batched } from 'elementos'\n\nconst counts$ = molecule({\n  count1: atom(10),\n  count2: atom(10)\n}, {\n  actions: ({ count1, count2 }) => ({\n    incrementAll: batched(() => {\n      count1.actions.increment()\n      throw new Error('rollback')\n      count2.actions.increment()\n    })\n  })\n})\n\nobserve(counts$, (counts) => {\n  console.log(counts)\n})\n\ntry {\n  counts$.actions.incrementAll()\n}\ncatch(err) {\n  console.log('error during batched update')\n}\n\n// Output:\n// { count1: 10, count2: 10 }\n// error during batched update\n")),Object(a.b)("h3",{id:"gets-and-sets"},"Gets and Sets"),Object(a.b)("p",null,"Every time a batched function is executed, a new transaction is created. When we call ",Object(a.b)("inlineCode",{parentName:"p"},"get")," or ",Object(a.b)("inlineCode",{parentName:"p"},"set")," methods on an observable while a batched call is pending, we will be getting and setting the value associated with the pending transaction and this value will not be finalized until the transaction is commited at the end of the batched call."),Object(a.b)("pre",null,Object(a.b)("code",Object(o.a)({parentName:"pre"},{className:"language-js"}),"import { atom, molecule, batched } from 'elementos'\n\nconst counts$ = molecule({\n  count1: atom(10),\n  count2: atom(10)\n}, {\n  actions: ({ count1, count2 }) => ({\n    incrementAll: batched(() => {\n      console.log(count1.get())\n      count1.actions.increment()\n      count2.actions.increment()\n      // Here we will get back the updated values \n      // associated with the pending transaction\n      console.log(count1.get())\n      throw new Error('rollback')\n    })\n  })\n})\n\ntry {\n  counts$.actions.incrementAll()\n}\ncatch(err) {\n  // But the transactions value will never be commited\n  console.log(count1.get())\n}\n\n// Output:\n// 10\n// 11\n// 10\n")))}u.isMDXComponent=!0},99:function(e,n,t){"use strict";t.d(n,"a",(function(){return b})),t.d(n,"b",(function(){return p}));var o=t(0),c=t.n(o);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function r(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?r(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):r(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function l(e,n){if(null==e)return{};var t,o,c=function(e,n){if(null==e)return{};var t,o,c={},a=Object.keys(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||(c[t]=e[t]);return c}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)t=a[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(c[t]=e[t])}return c}var s=c.a.createContext({}),u=function(e){var n=c.a.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},b=function(e){var n=u(e.components);return c.a.createElement(s.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return c.a.createElement(c.a.Fragment,{},n)}},m=c.a.forwardRef((function(e,n){var t=e.components,o=e.mdxType,a=e.originalType,r=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),b=u(t),m=o,p=b["".concat(r,".").concat(m)]||b[m]||d[m]||a;return t?c.a.createElement(p,i(i({ref:n},s),{},{components:t})):c.a.createElement(p,i({ref:n},s))}));function p(e,n){var t=arguments,o=n&&n.mdxType;if("string"==typeof e||o){var a=t.length,r=new Array(a);r[0]=m;var i={};for(var l in n)hasOwnProperty.call(n,l)&&(i[l]=n[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var s=2;s<a;s++)r[s]=t[s];return c.a.createElement.apply(null,r)}return c.a.createElement.apply(null,t)}m.displayName="MDXCreateElement"}}]);